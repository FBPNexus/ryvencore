{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the ryvencore documentation! Looking for a quick start? Visit the Getting Started section. Project Idea ryvencore is an easy to use framework for creating Qt based flow-based visual scripting editors for Python. ryvencore comes from the Ryven project, a flexible flow-based visual scripting environment for Python. The core concepts of Ryven are now implemented in ryvencore and will be the base also for Ryven itself from now on. Info Since the biggest part of the code deals with management of the GUI (in particular drawing and interaction of nodes and flows) and a package not implementing this wouldn't contain much, ryvencore already provides you with those GUI classes, so it's not GUI independent, it depends on Qt (currently PySide2). There might be ways to integrate the PySide-based widgets of ryvencore into other GUI frameworks, but it is recommended that you use a Qt-based environment. Also notice that, compared to PyQt, PySide2 is licensed under the more flexible LGPL license. Warning ryvencore is not a professional piece of software and sometimes there are major changes. If you have suggestions for improvement of the software, feel free to open discussions and PRs. Besides essential GUI classes, ryvencore also provides you with a few convenience GUI classes which you may want to use, which only use ryvencore's public API, making it much easier to get started. Current State In it's current state ryvencore is still experimental. It works well so far and I will use it to create a few more specific visual scripting editors for Python. But it's pretty much in alpha state. Resources May I also point to the website of the Ryven project if you haven't been there already. And there's a YouTube channel , tutorials and stuff are planned.","title":"Welcome"},{"location":"#welcome-to-the-ryvencore-documentation","text":"Looking for a quick start? Visit the Getting Started section.","title":"Welcome to the ryvencore documentation!"},{"location":"#project-idea","text":"ryvencore is an easy to use framework for creating Qt based flow-based visual scripting editors for Python. ryvencore comes from the Ryven project, a flexible flow-based visual scripting environment for Python. The core concepts of Ryven are now implemented in ryvencore and will be the base also for Ryven itself from now on. Info Since the biggest part of the code deals with management of the GUI (in particular drawing and interaction of nodes and flows) and a package not implementing this wouldn't contain much, ryvencore already provides you with those GUI classes, so it's not GUI independent, it depends on Qt (currently PySide2). There might be ways to integrate the PySide-based widgets of ryvencore into other GUI frameworks, but it is recommended that you use a Qt-based environment. Also notice that, compared to PyQt, PySide2 is licensed under the more flexible LGPL license. Warning ryvencore is not a professional piece of software and sometimes there are major changes. If you have suggestions for improvement of the software, feel free to open discussions and PRs. Besides essential GUI classes, ryvencore also provides you with a few convenience GUI classes which you may want to use, which only use ryvencore's public API, making it much easier to get started.","title":"Project Idea"},{"location":"#current-state","text":"In it's current state ryvencore is still experimental. It works well so far and I will use it to create a few more specific visual scripting editors for Python. But it's pretty much in alpha state.","title":"Current State"},{"location":"#resources","text":"May I also point to the website of the Ryven project if you haven't been there already. And there's a YouTube channel , tutorials and stuff are planned.","title":"Resources"},{"location":"api/","text":"API Reference [class] Session A session is the top-most interface to your components. Usually you will want to create one session per application instance, but you could create multiple ones to have different independent environments in one application. Signals The following signals are useful if you use custom widgets for listing the scripts. You can connect these signals to the corresponding GUI classes to make your GUI adapt. These signals equally apply on function-scripts. Name Parameters Description new_script_created Script Emitted when a new script is created. script_renamed Script Emitted when a script has been renamed. script_deleted Script Emitted when a script has been deleted. Attributes Name Description nodes A list of all registered nodes. design The session's Design reference. Methods Session(flow_performance_mode: str = 'pretty', animations_enabled: bool = True, flow_theme_name: str = 'ueli', flow_data_conn_class=DataConnection, flow_exec_conn_class=ExecConnection, project: dict = None) Parameter Description threaded: bool = False True for threaded applications. gui_parent: QObject = None The parent (i.e. MainWindow) for the GUI, only important for threaded applications gui_thread: QThread = None The main thread, only important for threaded applications flow_theme_name The name of the flow theme used performance_mode 'pretty' or 'fast' data_conn_class=None A ref to your custom implementation of DataConnection if you want to provide one. data_conn_item_class=None A ref to your custom implementation of DataConnectionItem if you want to provide one. exec_conn_class=None A ref to your custom implementation of ExecConnection if you want to provide one. exec_conn_item_class=None A ref to your custom implementation of ExecConnectionItem if you want to provide one. parent: QObject = None The session's parent object. This list (and especially the order) might get changed in the future multiple times, so make sure you always use the parameter names. Also, while I think subclassing the connection classes is a great feature, the default class's implementations are young and might receive changes in the future. register_node(node) Registers a Node which then can be accessed in all scripts, Note You can register nodes at any time! register_nodes(node_classes: list) Convenience class for registering a list of nodes at once. unregister_node(node_class) Unregisters a node which will then be removed from the internal list. Existing instances won't be affected. create_script(title: str, flow_view_size: list = None, create_default_logs=True) -> Script Parameter Description title The title of the new script. Script titles have to be unique. flow_view_size the pixel size of the flow in format [x, y] . create_default_logs Indicates whether the script's default logs ( Global and Errors ) should get created. You can also do this later manually via Script.logger.create_default_logs() . Creates and returns a script which triggers the Session.new_script_created() signal. By the time the script is returned, all abstract as well as the GUI components have been created. create_func_script(title: str, flow_view_size: list = None, create_default_logs=True) -> Script Same thing as Session.create_script() for FunctionScript s. all_scripts() -> list Returns a list containing all scripts and function scripts. check_new_script_title_validity(title: str) -> bool Checks whether a considered title for a new script (i.e. unique) is valid or not. rename_script(script: Script, title: str) Renames an existing script which triggers the Session.script_renamed signal. delete_script(script: Script) Deletes a script and triggers the Session.script_deleted signal. load(project: dict) -> bool Loads a project, which means creating all scripts saved in the provided project dict and building all their contents including the flows. serialize() -> dict Returns the project as dict to be saved and loaded again using load(). info_messenger() Returns a reference to the InfoMsgs class for printing only if info messages are enabled. all_nodes() -> list Returns a list of all Node instances (objects) from all flows of the session's scripts. set_stylesheet(s: str) Sets the session's global stylesheet which can be accessed by nodes and their widgets. [class] InfoMsgs The InfoMsgs class just provides a convenient way to print, such that the additional info is disabled by default but can be enabled for troubleshooting. Methods enable() Enables the printing. disable() Disables the printing. write(*args) Writes a list of arguments stringified using str() in the same format print() does. write_err(*args) Same as write(*args) but for highlighted errors. [class] Script Attributes Name Description session a ref to the session flow the script's flow flow view the script's flow view, which is the GUI representative of the flow logger the script's logger vars_manager the script's vars manager for managing the script variables title the script's current tile The FunctionScript class used for function scripts extends the Script 's functionality by a few things such as input node and output node that get added automatically to the flow. [class] Logger The logger manages all the logs of a script. Signals Name Parameters Description new_log_created Log Emitted when a new Log has been created, either manually through new_log() or automatically (default logs). Attributes Name Description script: Script A ref to the script. logs: list A list of all the logs registered in the script. Methods create_default_logs() Creates the default script's logs Global and Errors . This is done automatically if you didn't disable default logs when creating the the script. log_message(msg: str, target: str = '') Logs a message to all logs with name target . If you want to print to a specific log individual log (not one of the default logs), you should use the Log.write() method. new_log(title: str) -> Log Creates an individual new log which you can use for anything. Emits the new_log_created signal. [class] Log Signals The following signals are useful if you implement your own log GUI. Connect them to your widget so it catches those events. Name Parameters Description enabled - Emitted when the log has been enabled. For instance when a Node which requested the log was removed from the flow and has been restored through an undo command, the logs get 'reenabled'. disabled - Emitted when the log has been disabled. For instance when a Node which requested the log has been removed from the flow. wrote str Emitted when something wrote a message to the log. cleared - Emitted when the log has been cleared. Attributes Name Description title: str The log's title string. lines: [str] A list of all logged strings (doesn't get cleared when the log gets cleared). current_lines: [str] All current lines , i.e. the ones that haven't been cleared. Methods write(*args) Writes a list of arguments to the log like print() does, stringifying everything using str() . clear() Clears the log and emits cleared . This doesn't clear the lines attribute! disable() Disables the log and emits disabled . A disabled log does not write anymore. enable() Enables the log and emits enabled . save_to_file(filepath: str, all_lines=True) Saves lines to a file. If all_lines is False it only saves current_lines . [class] VarsManager Signals The following signals are useful if you implement your own script vars list GUI. Name Parameters Description new_var_created Variable Emitted when a new script variable has been created. var_deleted Variable Emitted when a script variable has been deleted. var_val_changed Variable, object Emitted when a script variable's value has been changed. Attributes Name Description variables: [Variable] A list of all the managed script vars. Methods check_new_var_name_validity(name: str) -> bool Checks whether name is a valid name for a new script variable. create_new_var(name: str, val=None) -> Variable Creates and returns a new script variable with given name and initial value. Emits the new_var_created signal. get_var(name) -> Variable Returns script variable with given name or None if it couldn't be found. get_var_val(name) Returns the value of a script variable with given name or None if it couldn't be found. set_var(name, val) -> bool Sets the value of an existing script variable. Returns False if the var couldn't be found. delete_variable(var: Variable) Deletes a script variable and emits var_deleted . register_receiver(receiver, var_name: str, method) Registers a var receiver. A registered receiver (method) gets triggered every time the value of a variable with the given name changes (also when it gets created). unregister_receiver(receiver, var_name: str) -> bool Unregisters a var receiver. [class] Flow The Flow class represents the abstract flow (no GUI) and stores all the node objects and connections. You can access a script's flow via Script.flow . Signals Name Parameters Emitted when... node_added Node a node has been added (also happens when a reoved node is restored through an undo). node_removed Node a node has been removed. connection_added Connection a connection has been added. connection_removed Connection a connection has been removed. algorithm_mode_changed str the flow's algorithm mode changed, see set_algorithm_mode() . Attributes Name Description nodes: [Node] A list of all currently present nodes. connections: [Connection] A list of all current connections. Methods create_node(node_class, config=None) Creates, adds and returns a new node object; emits node_added. remove_node(node: Node) Removes a node from internal list without deleting it; emits node_removed. algorithm_mode() -> str Returns the flow's current algorithms mode ( data for data flow or exec for execution flow ). By default, flows run in data flow mode. set_algorithm_mode(mode: str) Parameter Description mode 'data' or 'exec' [class] FlowView The FlowView is the GUI representative for the Flow , i.e. the widget, and is accessible via Script.flow_view . get_viewport_img() -> QImage Returns a clear image of the viewport. get_whole_scene_img() -> QImage Returns an image of the whole scene, scaled accordingly to current scale factor. Bug Currently, this only works from the viewport's position down and right, so the user has to scroll to the top left corner in order to get the full scene. show_framerate(show: bool = True, m_sec_interval: int = 1000) WIP [class] Node Nodes are defined by subclasses of Node . The individual objects will be instances of the according class. The Node class contains the whole API for programming nodes. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class PrintNode ( rc . Node ): title = 'Print' description = 'prints your data' init_inputs = [ rc . NodeInput ( 'data' ) ] init_outputs = [] color = '#A9D5EF' # we could also skip the constructor here def __init__ ( self , params ): super () . __init__ ( params ) def update_event ( self , input_called =- 1 ): data = self . input ( 0 ) # get data from the first input print ( data ) Static Attributes Use the following static attributes to define the basic properties of your node. Name Description title: str The Node's initial title. It doesn't have to be unique. type_: str Optional way to specify the node. init_inputs: [NodeInput] Initial inputs. init_outputs: [NodeOutput] Initial outputs. identifier: str A unique identifier string. If nothing is provided, the node's class name will be used. description: str A description shown as tool tip when hovering about the node. description_html: str A description in html format. main_widget_class: list A reference to the class of the main_widget if used. main_widget_pos: str 'between ports' or 'below ports' if a main_widget is used. input_widget_classes: dict A dict for custom input widgets in format {name: class} which can then be used when defining initial data inputs or creating ones at runtime. style: str 'extended' (default) or 'small' . Those are the two different design styles for nodes. color: str A color in hex format. icon: str The file path to an icon. Methods [override] update_event(input_called=-1) Triggered when the Node is activated, usually through Node.update() . Example An arr get Node's update event could look like this: 1 2 3 4 def update_event ( self , input_called =- 1 ): arr = self . input ( 0 ) index = self . input ( 1 ) self . set_output_val ( 0 , arr [ index ]) [override] get_data() -> dict In this method, you need to provide all your internal data that defines your Node's current state (if there are different states). The dict will be encoded using pickle and base64 when copying nodes (via ctrl+c) or when saving the project. You do the reverse in Node.set_data(data) (see below). Example Example for a + Node with a dynamic number of inputs, which can be changed by the user. 1 2 3 def get_data ( self ): data = { 'num inputs' : self . num_inputs } return data [override] set_data(data: dict) Parameter Description data Holds the exact value you returned in Node.get_data() . Here you do the reverse of what you did in Node.get_data() . Important Note that all ryvencore internal objects, such as the special_actions dict, as well as inputs and outputs get saved and restored automatically by ryvencore exactly as they were when the flow was saved. So, if you added some inputs for example, don't add them again manually in set_data() according to your attribute which indicates how many you added, this happens automatically. Just update your own internal variables. Example 1 2 def set_data ( self , data ): self . num_inputs = data [ 'num inputs' ] [override] place_event() Triggered when the Node has been added to the flow and all GUI has been initialized . Don't try to access GUI components in the constructor, they don't exist yet, use this method instead. [override] remove_event() Triggered when the Node is removed from the flow. You can use this method do stop threads and timers etc. Note that this action might be undone by an undo operation by the user, in this case the exact Node object will just be placed again resulting in a place_event() . Example Example from a clock Node running a timer. 1 2 def remove_event ( self ): self . timer . stop () update(input_called=-1) Parameter Description input_called If the Node is active, living in an exec flow, i.e. if it has exec inputs, you might want to pass the input the update is supposed to refer to. Triggers an update event. input(index: int) Returns the data that is at the data input with given index. If the input is not connected, the input will return the widget's data (if it has a widget), otherwise it will return the data from the output of the connected Node. In all other cases, it returns None . exec_output(index: int) Parameter Description index Index of the output. It has to be an exec output. Executes the output with given index. set_output_val(index: int, val) Parameter Description index Index of the output. It has to be a data output. val The data that gets set at the output. This can be anything. In dataflows, this causes update events in all connected nodes. This way, change of data is forward propagated through all nodes that depend on it. new_log(title: str) -> Log Parameter Description title The log's display title. Creates and returns a new log, owned by the Node. disable_logs() Disables all logs owned by the Node. The convenience Log widget ryvencore provides then can be hidden. All logs owned by a Node automatically get disabled when the Node is removed. enable_logs() Enables all logs owned by the Node. The convenience Log widget ryvencore provides then shows the widget again, in case it has been hidden after it was disabled. All logs owned by a Node automatically get enabled again when a removed Node is restored through an undo operation. log_message(msg: str, target: str) Parameter Description msg The message as string. target 'Global' or 'Errors' . Refers to one of the script's default logs. update_shape() Causes recompilation of the whole shape of the GUI item of the node. create_input(type_: str = 'data', label: str = '', widget_name=None, widget_pos='besides', pos=-1, ...) Parameter Description type_ 'data' or 'exec' label The input's displayed label string. widget_name The name the input widget has been registered under. None means no widget gets used. widget_pos 'besides' or 'below' the port. pos The index this input should be inserted at. -1 means appending at the end. delete_input(i) Deletes the input at index i . All existing connections get removed automatically. create_output(type_: str = 'data', label: str = '', pos=-1) Parameter Description type_ 'data' or 'exec' label The output's displayed label string. pos The index this output should be inserted at. -1 means appending at the end. delete_output(o) Deletes the output at index o . All existing connections get removed automatically. session_stylesheet() -> str Returns the stylesheet registered via Session.set_stylesheet() . This can be useful for custom widgets. get_var_val(name: str) Parameter Description name script variable's name Returns the current value of a script variable and None if it couldn't be found. set_var_val(name: str, val) Parameter Description name script variable's name val the variable's value Sets the value of a script variable and causes all registered receivers to update (see below). register_var_receiver(name: str, method) Parameter Description name script variable's name method a reference to the receiver method Registers a method as receiver for changes of script variable with given name. Example 1 2 3 4 # connect to variable changes # self.var_val_updated refers to the receiver method self . register_var_receiver ( 'x' , self . var_val_updated ) self . used_variable_names . append ( 'x' ) unregister_var_receiver(name: str) Unregisters a previously registered variable receiver.","title":"API Reference"},{"location":"api/#api-reference","text":"","title":"API Reference"},{"location":"api/#class-session","text":"A session is the top-most interface to your components. Usually you will want to create one session per application instance, but you could create multiple ones to have different independent environments in one application.","title":"[class] Session"},{"location":"api/#signals","text":"The following signals are useful if you use custom widgets for listing the scripts. You can connect these signals to the corresponding GUI classes to make your GUI adapt. These signals equally apply on function-scripts. Name Parameters Description new_script_created Script Emitted when a new script is created. script_renamed Script Emitted when a script has been renamed. script_deleted Script Emitted when a script has been deleted.","title":"Signals"},{"location":"api/#attributes","text":"Name Description nodes A list of all registered nodes. design The session's Design reference.","title":"Attributes"},{"location":"api/#methods","text":"","title":"Methods"},{"location":"api/#class-infomsgs","text":"The InfoMsgs class just provides a convenient way to print, such that the additional info is disabled by default but can be enabled for troubleshooting.","title":"[class] InfoMsgs"},{"location":"api/#methods_1","text":"","title":"Methods"},{"location":"api/#class-script","text":"","title":"[class] Script"},{"location":"api/#attributes_1","text":"Name Description session a ref to the session flow the script's flow flow view the script's flow view, which is the GUI representative of the flow logger the script's logger vars_manager the script's vars manager for managing the script variables title the script's current tile The FunctionScript class used for function scripts extends the Script 's functionality by a few things such as input node and output node that get added automatically to the flow.","title":"Attributes"},{"location":"api/#class-logger","text":"The logger manages all the logs of a script.","title":"[class] Logger"},{"location":"api/#signals_1","text":"Name Parameters Description new_log_created Log Emitted when a new Log has been created, either manually through new_log() or automatically (default logs).","title":"Signals"},{"location":"api/#attributes_2","text":"Name Description script: Script A ref to the script. logs: list A list of all the logs registered in the script.","title":"Attributes"},{"location":"api/#methods_2","text":"","title":"Methods"},{"location":"api/#class-log","text":"","title":"[class] Log"},{"location":"api/#signals_2","text":"The following signals are useful if you implement your own log GUI. Connect them to your widget so it catches those events. Name Parameters Description enabled - Emitted when the log has been enabled. For instance when a Node which requested the log was removed from the flow and has been restored through an undo command, the logs get 'reenabled'. disabled - Emitted when the log has been disabled. For instance when a Node which requested the log has been removed from the flow. wrote str Emitted when something wrote a message to the log. cleared - Emitted when the log has been cleared.","title":"Signals"},{"location":"api/#attributes_3","text":"Name Description title: str The log's title string. lines: [str] A list of all logged strings (doesn't get cleared when the log gets cleared). current_lines: [str] All current lines , i.e. the ones that haven't been cleared.","title":"Attributes"},{"location":"api/#methods_3","text":"","title":"Methods"},{"location":"api/#class-varsmanager","text":"","title":"[class] VarsManager"},{"location":"api/#signals_3","text":"The following signals are useful if you implement your own script vars list GUI. Name Parameters Description new_var_created Variable Emitted when a new script variable has been created. var_deleted Variable Emitted when a script variable has been deleted. var_val_changed Variable, object Emitted when a script variable's value has been changed.","title":"Signals"},{"location":"api/#methods_4","text":"","title":"Methods"},{"location":"api/#class-flow","text":"The Flow class represents the abstract flow (no GUI) and stores all the node objects and connections. You can access a script's flow via Script.flow .","title":"[class] Flow"},{"location":"api/#signals_4","text":"Name Parameters Emitted when... node_added Node a node has been added (also happens when a reoved node is restored through an undo). node_removed Node a node has been removed. connection_added Connection a connection has been added. connection_removed Connection a connection has been removed. algorithm_mode_changed str the flow's algorithm mode changed, see set_algorithm_mode() .","title":"Signals"},{"location":"api/#methods_5","text":"","title":"Methods"},{"location":"api/#class-flowview","text":"The FlowView is the GUI representative for the Flow , i.e. the widget, and is accessible via Script.flow_view .","title":"[class] FlowView"},{"location":"api/#class-node","text":"Nodes are defined by subclasses of Node . The individual objects will be instances of the according class. The Node class contains the whole API for programming nodes. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class PrintNode ( rc . Node ): title = 'Print' description = 'prints your data' init_inputs = [ rc . NodeInput ( 'data' ) ] init_outputs = [] color = '#A9D5EF' # we could also skip the constructor here def __init__ ( self , params ): super () . __init__ ( params ) def update_event ( self , input_called =- 1 ): data = self . input ( 0 ) # get data from the first input print ( data )","title":"[class] Node"},{"location":"api/#static-attributes","text":"Use the following static attributes to define the basic properties of your node. Name Description title: str The Node's initial title. It doesn't have to be unique. type_: str Optional way to specify the node. init_inputs: [NodeInput] Initial inputs. init_outputs: [NodeOutput] Initial outputs. identifier: str A unique identifier string. If nothing is provided, the node's class name will be used. description: str A description shown as tool tip when hovering about the node. description_html: str A description in html format. main_widget_class: list A reference to the class of the main_widget if used. main_widget_pos: str 'between ports' or 'below ports' if a main_widget is used. input_widget_classes: dict A dict for custom input widgets in format {name: class} which can then be used when defining initial data inputs or creating ones at runtime. style: str 'extended' (default) or 'small' . Those are the two different design styles for nodes. color: str A color in hex format. icon: str The file path to an icon.","title":"Static Attributes"},{"location":"api/#methods_6","text":"","title":"Methods"},{"location":"conv_gui/","text":"Convenience GUI Classes Just a quick overview over the currently available convenience GUI classes. Meaning, all those classes only use ryvencore's public API and you could implement them all yourself. The list should grow over time. All these classes come from Ryven so far. Script List Widget A simple list widget for creating, renaming and deleting scripts and function-scripts. To catch the according events (i.e. script_created , script_renamed etc), use the signals of Session . Variables List Widget A synchronous widget to the script list widget for script variables. You can create, rename, delete script variables and change their values which results in all registered receivers to update. Log Widget A very basic widget for outputting data of a log. Use the Script.logger.new_log_created() signal to catch instantiation of new logs. If you want to implement your own, you will need the Log 's signals enabled , disabled , cleared , wrote . Input Widgets std line edit aka std line edit m , std line edit s , std line edit l std spin box For styling those, refer to thir classes RCIW_BUILTIN_LineEdit , RCIW_BUILTIN_SpinBox . I really would like to add many more widgets to this list in the future.","title":"Convenience GUI"},{"location":"conv_gui/#convenience-gui-classes","text":"Just a quick overview over the currently available convenience GUI classes. Meaning, all those classes only use ryvencore's public API and you could implement them all yourself. The list should grow over time. All these classes come from Ryven so far.","title":"Convenience GUI Classes"},{"location":"conv_gui/#script-list-widget","text":"A simple list widget for creating, renaming and deleting scripts and function-scripts. To catch the according events (i.e. script_created , script_renamed etc), use the signals of Session .","title":"Script List Widget"},{"location":"conv_gui/#variables-list-widget","text":"A synchronous widget to the script list widget for script variables. You can create, rename, delete script variables and change their values which results in all registered receivers to update.","title":"Variables List Widget"},{"location":"conv_gui/#log-widget","text":"A very basic widget for outputting data of a log. Use the Script.logger.new_log_created() signal to catch instantiation of new logs. If you want to implement your own, you will need the Log 's signals enabled , disabled , cleared , wrote .","title":"Log Widget"},{"location":"conv_gui/#input-widgets","text":"std line edit aka std line edit m , std line edit s , std line edit l std spin box For styling those, refer to thir classes RCIW_BUILTIN_LineEdit , RCIW_BUILTIN_SpinBox . I really would like to add many more widgets to this list in the future.","title":"Input Widgets"},{"location":"features/","text":"Features This site gives a slightly more detailed overview over ryvencore's specific features. I will introduce the major systems here. Nodes System In ryvencore, nodes are defined subclasses of ryvencore's Node class. Single nodes will be instances of this class and basic properties that equally apply on all those nodes are stored as static attributes. Individually changing properties are inputs and outputs (which can be added and removed at any time), display title, \"actions\" which are right click operations etc. You can put any code into your Node subclasses, no limitations. One very important feature is the possibility of defining custom GUI components, i.e. widgets, for your nodes. A node can have a main_widget and input widgets, whose classes are stored in the input_widget_classes attribute. Special Actions Special actions are a very simple way to define right click operations for your nodes. The special_actions attribute is a dictionary which you can edit like this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # creating a new entry self . special_actions [ 'add some input' ] = { 'method' : self . add_some_input_action } # with a corresponding method def add_some_input_action ( self ): self . create_input ( type_ = 'data' , label = 'new input' ) # removing an entry del self . special_actions [ 'add some input' ] # and storing individual data for multiple actions pointing to the same target method # which enables completely dynamic and current state dependent actions self . special_actions [ 'add some input at index 0' ] = { 'method' : self . add_some_input_at , 'data' : 0 } self . special_actions [ 'add some input at index 1' ] = { 'method' : self . add_some_input_at , 'data' : 1 } def add_some_input_at ( self , index ): self . create_input ( type_ = 'data' , label = 'inserted input' , pos = index ) Load&Save The whole load and save process of projects is done by ryvencore, see Session.serialize() , Session.load() . Before loading a project, you need to register all required nodes in the session. Script Variables Script variables are a nice way to improve the interface to your data. There is a ridiculously simple but extremely powerful registration system that lets you register methods as receivers for a variable with a given name. Then, every time the variable's value gets updated, all registered receiver methods are called. The registration process is part of the API of the Node class, so you can easily create highly responsive nodes. Example I made a small Matrix node in Ryven where you can just type a few numbers into a small textedit (which is the custom main_widget of the node) and it creates a numpy array out of them. But you can also type in the name of a script variable somewhere (instead of a number) which makes the matrix node register as a receiver, so it updates and regenerates the matrix every time the value of a script variable with that name updated. Note You could also work with default variables, for example, that you always create when creating a new script, by default, which all your nodes use to communicate or transmit data in more complex ways. This illustrates, there is really a bunch of quite ridiculous possibilities for sophisticated optimization with this. Logging There is a Logger class which every script has an instance of. You can use the logger's API to write messages to default logs and to request custom logs and write directly to them. The Node 's API already includes methods for requesting custom logs and manages enable -and disable -events according to actions in the flow (like removing the Node), but you can also request logs for anything else. Convenience Classes ryvecore already comes with a few convenience classes for widgets. Those convenience classes only use ryvencore's public API, so if you have experience with Qt, you can totally implemenent them yourself. But in most cases they make it much easier to get started. See convenience GUI section . Styling Of course, design splays a huge role when thinking about visual scripting. Therefore, you have wide freedom in styling. Flow Themes There is a list of available flow themes (which I want to expand as far as possible). You can choose one via Session.design.set_flow_theme() . Currently available flow themes are Samuel 1d , Samuel 1l , Samuel 2d , Samuel 2l , Ueli , Blender , Simple , Toy and Tron . To make sure you can create a look that fits in nicely wherever you might integrate your editor, you can customize the colors for all the above themes using a config json file and passing it to the design using Sessiong.design.load_from_config(filepath) . The json file should look like this, for any value you can either write \"default\" or specify a specific setting according to the instructions in the info box. config file You can also specify the initial flow theme, the performance mode ( 'pretty' or 'fast' ) and animations (which currently don't work I think). You can just copy the following json, save it in a file and specify. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 { \"init flow theme\" : \"Samuel 1l\" , \"init performance mode\" : \"pretty\" , \"init animations enabled\" : true , \"flow themes\" : { \"Toy\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" }, \"Tron\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" }, \"Ghost\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"nodes color\" : \"default\" , \"small nodes color\" : \"default\" }, \"Blender\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"nodes color\" : \"default\" }, \"Simple\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"nodes background color\" : \"default\" , \"small nodes background color\" : \"default\" }, \"Ueli\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"nodes background color\" : \"default\" , \"small nodes background color\" : \"default\" }, \"Samuel 1d\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"extended node background color\" : \"default\" , \"small node background color\" : \"default\" , \"node title color\" : \"default\" , \"port pin pen color\" : \"default\" }, \"Samuel 1l\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"extended node background color\" : \"default\" , \"small node background color\" : \"default\" , \"node title color\" : \"default\" , \"port pin pen color\" : \"default\" } } } Also note that the syntax of these configurations might receive some changes in the future. Give non-default values for widths in number format, not str . Possible values for pen styles are solid line , dash line , dash dot line , dash dot dot line and dot line . Give color as string in hex format (also compatible with alpha values like #aabb4499 ). StyleSheets ryvencore itself applies relatively little stylesheets itself, so you can apply your own style and most of the built in widgets should adapt accordingly. You can also store a stylesheet via Session.set_stylesheet() which is then accessible in nodes and their widget classes via Node.session_stylesheet() . When making a larger editor, you can style the builtin widgets (like the builtin input widgets for nodes) by referencing their class names in your css (aka qss) file. Customizing Connections You can provide your own reimplementations of the connection classes, since this is an excellent point to add domain-specific additional functionality (like 'edge weights') to your editor. There are no detailed instructions on that in the docs yet, but you can take a look at the implementations, and then pass your implementations of the classes you want to enhance to the Session 's constructor, see API . Flow Features ryvencore's FlowView class, which is a subclass of QGraphicsView , supports some special features such as stylus support for adding simple handwritten notes rendered images of the flow including high res for presentations algorithm modes for the flow (data and exec) Code Generation [idea] Now, there currently isn't a code generation mechanism for ryvencore, however I already implemented a prototype for Ryven once and Ryven 3 will probably receive this as an official feature at some point. The requirements for something like this actually only regard the file structure of your node definitions, so it might make sense to add this at some point to ryvencore if it turns out that this file structure usually is pretty much the same. If you are coming from Ryven and want to contribute to the development, this would be something that I'm sure some people using the software are much more capable of implementing than I am. Continuing is some thoughts for people who want to work on this: Note Files might get large! Because the resulting code has to include this abstract version of the whole internal structure as well as the definitions of all used nodes, the resulting code might quickly reach 1000 lines. The resulting code should be completely independent without Qt dependencies. When generating the code, Ryven runs a dependency analysis of all nodes' sources. Some nodes might just use standard packages and modules (like numpy), while others might include external sources that one wants to have included in the generated code, like some functions or classes used by many of your nodes which are therefore kept in their own modules. Ryven analyzes normal (module-wide) import statements recursively and includes all sources that are not builtin modules or installed packages or part of an ignore list.","title":"Features"},{"location":"features/#features","text":"This site gives a slightly more detailed overview over ryvencore's specific features. I will introduce the major systems here.","title":"Features"},{"location":"features/#nodes-system","text":"In ryvencore, nodes are defined subclasses of ryvencore's Node class. Single nodes will be instances of this class and basic properties that equally apply on all those nodes are stored as static attributes. Individually changing properties are inputs and outputs (which can be added and removed at any time), display title, \"actions\" which are right click operations etc. You can put any code into your Node subclasses, no limitations. One very important feature is the possibility of defining custom GUI components, i.e. widgets, for your nodes. A node can have a main_widget and input widgets, whose classes are stored in the input_widget_classes attribute.","title":"Nodes System"},{"location":"features/#special-actions","text":"Special actions are a very simple way to define right click operations for your nodes. The special_actions attribute is a dictionary which you can edit like this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # creating a new entry self . special_actions [ 'add some input' ] = { 'method' : self . add_some_input_action } # with a corresponding method def add_some_input_action ( self ): self . create_input ( type_ = 'data' , label = 'new input' ) # removing an entry del self . special_actions [ 'add some input' ] # and storing individual data for multiple actions pointing to the same target method # which enables completely dynamic and current state dependent actions self . special_actions [ 'add some input at index 0' ] = { 'method' : self . add_some_input_at , 'data' : 0 } self . special_actions [ 'add some input at index 1' ] = { 'method' : self . add_some_input_at , 'data' : 1 } def add_some_input_at ( self , index ): self . create_input ( type_ = 'data' , label = 'inserted input' , pos = index )","title":"Special Actions"},{"location":"features/#loadsave","text":"The whole load and save process of projects is done by ryvencore, see Session.serialize() , Session.load() . Before loading a project, you need to register all required nodes in the session.","title":"Load&amp;Save"},{"location":"features/#script-variables","text":"Script variables are a nice way to improve the interface to your data. There is a ridiculously simple but extremely powerful registration system that lets you register methods as receivers for a variable with a given name. Then, every time the variable's value gets updated, all registered receiver methods are called. The registration process is part of the API of the Node class, so you can easily create highly responsive nodes. Example I made a small Matrix node in Ryven where you can just type a few numbers into a small textedit (which is the custom main_widget of the node) and it creates a numpy array out of them. But you can also type in the name of a script variable somewhere (instead of a number) which makes the matrix node register as a receiver, so it updates and regenerates the matrix every time the value of a script variable with that name updated. Note You could also work with default variables, for example, that you always create when creating a new script, by default, which all your nodes use to communicate or transmit data in more complex ways. This illustrates, there is really a bunch of quite ridiculous possibilities for sophisticated optimization with this.","title":"Script Variables"},{"location":"features/#logging","text":"There is a Logger class which every script has an instance of. You can use the logger's API to write messages to default logs and to request custom logs and write directly to them. The Node 's API already includes methods for requesting custom logs and manages enable -and disable -events according to actions in the flow (like removing the Node), but you can also request logs for anything else.","title":"Logging"},{"location":"features/#convenience-classes","text":"ryvecore already comes with a few convenience classes for widgets. Those convenience classes only use ryvencore's public API, so if you have experience with Qt, you can totally implemenent them yourself. But in most cases they make it much easier to get started. See convenience GUI section .","title":"Convenience Classes"},{"location":"features/#styling","text":"Of course, design splays a huge role when thinking about visual scripting. Therefore, you have wide freedom in styling.","title":"Styling"},{"location":"features/#flow-themes","text":"There is a list of available flow themes (which I want to expand as far as possible). You can choose one via Session.design.set_flow_theme() . Currently available flow themes are Samuel 1d , Samuel 1l , Samuel 2d , Samuel 2l , Ueli , Blender , Simple , Toy and Tron . To make sure you can create a look that fits in nicely wherever you might integrate your editor, you can customize the colors for all the above themes using a config json file and passing it to the design using Sessiong.design.load_from_config(filepath) . The json file should look like this, for any value you can either write \"default\" or specify a specific setting according to the instructions in the info box. config file You can also specify the initial flow theme, the performance mode ( 'pretty' or 'fast' ) and animations (which currently don't work I think). You can just copy the following json, save it in a file and specify. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 { \"init flow theme\" : \"Samuel 1l\" , \"init performance mode\" : \"pretty\" , \"init animations enabled\" : true , \"flow themes\" : { \"Toy\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" }, \"Tron\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" }, \"Ghost\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"nodes color\" : \"default\" , \"small nodes color\" : \"default\" }, \"Blender\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"nodes color\" : \"default\" }, \"Simple\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"nodes background color\" : \"default\" , \"small nodes background color\" : \"default\" }, \"Ueli\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"nodes background color\" : \"default\" , \"small nodes background color\" : \"default\" }, \"Samuel 1d\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"extended node background color\" : \"default\" , \"small node background color\" : \"default\" , \"node title color\" : \"default\" , \"port pin pen color\" : \"default\" }, \"Samuel 1l\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"extended node background color\" : \"default\" , \"small node background color\" : \"default\" , \"node title color\" : \"default\" , \"port pin pen color\" : \"default\" } } } Also note that the syntax of these configurations might receive some changes in the future. Give non-default values for widths in number format, not str . Possible values for pen styles are solid line , dash line , dash dot line , dash dot dot line and dot line . Give color as string in hex format (also compatible with alpha values like #aabb4499 ).","title":"Flow Themes"},{"location":"features/#stylesheets","text":"ryvencore itself applies relatively little stylesheets itself, so you can apply your own style and most of the built in widgets should adapt accordingly. You can also store a stylesheet via Session.set_stylesheet() which is then accessible in nodes and their widget classes via Node.session_stylesheet() . When making a larger editor, you can style the builtin widgets (like the builtin input widgets for nodes) by referencing their class names in your css (aka qss) file.","title":"StyleSheets"},{"location":"features/#customizing-connections","text":"You can provide your own reimplementations of the connection classes, since this is an excellent point to add domain-specific additional functionality (like 'edge weights') to your editor. There are no detailed instructions on that in the docs yet, but you can take a look at the implementations, and then pass your implementations of the classes you want to enhance to the Session 's constructor, see API .","title":"Customizing Connections"},{"location":"features/#flow-features","text":"ryvencore's FlowView class, which is a subclass of QGraphicsView , supports some special features such as stylus support for adding simple handwritten notes rendered images of the flow including high res for presentations algorithm modes for the flow (data and exec)","title":"Flow Features"},{"location":"features/#code-generation-idea","text":"Now, there currently isn't a code generation mechanism for ryvencore, however I already implemented a prototype for Ryven once and Ryven 3 will probably receive this as an official feature at some point. The requirements for something like this actually only regard the file structure of your node definitions, so it might make sense to add this at some point to ryvencore if it turns out that this file structure usually is pretty much the same. If you are coming from Ryven and want to contribute to the development, this would be something that I'm sure some people using the software are much more capable of implementing than I am. Continuing is some thoughts for people who want to work on this: Note Files might get large! Because the resulting code has to include this abstract version of the whole internal structure as well as the definitions of all used nodes, the resulting code might quickly reach 1000 lines. The resulting code should be completely independent without Qt dependencies. When generating the code, Ryven runs a dependency analysis of all nodes' sources. Some nodes might just use standard packages and modules (like numpy), while others might include external sources that one wants to have included in the generated code, like some functions or classes used by many of your nodes which are therefore kept in their own modules. Ryven analyzes normal (module-wide) import statements recursively and includes all sources that are not builtin modules or installed packages or part of an ignore list.","title":"Code Generation [idea]"},{"location":"getting_started/","text":"Getting Started Installation pip install ryvencore or from sources 1 2 3 git clone https://github.com/leon-thomm/ryvencore cd ryvencore python setup.py install Python 3.8+ recommended First Editor Info You can copy the full example code at the bottom of this page. Let's build our first editor. First thing is importing ryvencore 1 import ryvencore as rc Overall Structure Your main interface to the current project is the Session , which you usually want to create one instance of per application (but you can create more). The constructor already gives options for configurations, but we can leave everything as default for now. 1 my_session = rc . Session () Now we want to create a flow, which is part of a Script , besides the script variables and the logs . The scripts are managed by the session, so we just call 1 script = my_session . create_script ( 'hello world' , flow_view_size = [ 800 , 500 ]) With the flow_view_size you can set the pixel size of the flow view that will be created and which you can access via script.flow_view . The flow itself is a QGraphicsView subclass, which is a GUI class of Qt, so you can directly embed it into your window. Setting Up a Window This is not a complete tutorial on getting started with Qt for Python, but setting up a basic GUI structure is quite simple. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import ryvencore as rc import sys from PySide2.QtWidgets import QMainWindow , QApplication if __name__ == \"__main__\" : # create a QApplication and a MainWindow # we'll subclass QMainWindow later app = QApplication () mw = QMainWindow () # creating the session session = rc . Session () # creating a script script = session . create_script ( 'hello world' , flow_view_size = [ 800 , 500 ]) # and setting the flow view as the window's central widget mw . setCentralWidget ( script . flow_view ) mw . show () sys . exit ( app . exec_ ()) And there we go, that's it. You can left click into the scene to see a node selection widget pop up. Well, there isn't any content yet to use, so let's add that. Nodes In ryvencore the nodes system works like this: A node's blueprint is defined by its class, making heavy use of Pythons static attributes system. As the accessible nodes are managed by the session, you need to register the classes of the nodes you want to use like this: 1 session . register_nodes ( list_of_nodes ) Notice You can put any code into your Node subclass, no limits! You can define additional classes, use external packages, basically everything you can do in a python class. Hint You can register (and unregister) nodes at any time! This enables dynamic import mechanisms as implemented in Ryven for example. Now let's define a simple node. For a detailed description of the members, take a look into the API reference . We'll just create a very simple print node, which prints data provided at an input every time the node is activated. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class PrintNode ( rc . Node ): # all basic properties title = 'Print' description = 'prints your data' # there is also description_html init_inputs = [ rc . NodeInput ( 'data' ) ] init_outputs = [] color = '#A9D5EF' # see API doc for a full list of all properties # we could also skip the constructor here def __init__ ( self , params ): super () . __init__ ( params ) def update_event ( self , input_called =- 1 ): data = self . input ( 0 ) # get data from the first input print ( data ) Make your class derive from rc.Node and then enhance it the way you like. The update_event is the important part, it gets triggered every time the node is supposed to update. Note While most flow-based visual scripting software out there implements either the approach of execution-flows or data-flows , ryvencore implements them both. That's what the input_called -parameter is for, you use it when creating active nodes for execution-flows. Generally, data flows are more flexible and powerful, but there are cases where exec flows make more sense, so I wanted to leave it as an option. And let's add another node which generates a random number in a given range, so we have something to print. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from random import random class RandNode ( rc . Node ): title = 'Rand' description = 'generates random float' init_inputs = [ rc . NodeInput ( 'data' , widget = 'std line edit' , widget_pos = 'besides' ) ] init_outputs = [ rc . NodeOutput ( 'data' ) ] color = '#fcba03' def update_event ( self , input_called =- 1 ): # random num between 0 and value at input val = random () * self . input ( 0 ) # setting the value of the first output self . set_output_val ( 0 , val ) Note the widget -and widget_pos -parameters in the NodePort which I explain in the following section. Input Widgets Data inputs can have widgets, more specifically a QWidget (which is a GUI class of Qt) or a subclass. Custom input widget classes can be registered for a node by listing them in the Node's static field input_widget_classes (see API ). However, ryvencore also provides you with a few builtin convenience classes (the list will grow in the future). For example the following code creates an input with an input field of the builtin type std line edit . 1 2 3 init_inputs = [ rc . NodeInput ( 'data' , widget = 'std line edit' , widget_pos = 'besides' ) ] Finishing Now you can run this and if everything works you already have a small editor with all major features. You can place the two nodes, connect them by mouse, type something into the random node's input field and hit enter to trigger the update. It will then update and the self.set_output_val(...) call will trigger the connected print node to update and print. Of course there is much more you can do. For example you can change the flow theme. 1 session = rc . Session ( flow_theme_name = 'Samuel 1l' ) Currently available flow themes are Samuel 1d , Samuel 1l , Samuel 2d , Samuel 2l , Ueli , Blender , Simple , Toy and Tron . And if that's not enough, you can configure the theme colors for those using a json config file, so you'll definitely be able to give your flows a look that fits in the application environment it's going to be a part of. You can also change the performance mode to fast which results in some changes in rendering. 1 2 3 4 session = rc . Session ( flow_theme_name = 'Ueli' , performance_mode = 'fast' , ) CODE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import ryvencore as rc import sys from PySide2.QtWidgets import QMainWindow , QApplication from random import random class PrintNode ( rc . Node ): # all basic properties title = 'Print' description = 'prints your data' # there is also description_html init_inputs = [ rc . NodeInput ( 'data' ) ] init_outputs = [] color = '#A9D5EF' # see API doc for a full list of all properties # we could also skip the constructor here def __init__ ( self , params ): super () . __init__ ( params ) def update_event ( self , input_called =- 1 ): data = self . input ( 0 ) # get data from the first input print ( data ) class RandNode ( rc . Node ): title = 'Rand' description = 'generates random float' init_inputs = [ rc . NodeInput ( 'data' , widget = 'std line edit' , widget_pos = 'besides' ) ] init_outputs = [ rc . NodeOutput ( 'data' ) ] color = '#fcba03' def update_event ( self , input_called =- 1 ): # random num between 0 and value at input val = random () * self . input ( 0 ) # setting the value of the first output self . set_output_val ( 0 , val ) if __name__ == \"__main__\" : # create a QApplication and a MainWindow # the QMainWindow will be subclassed later app = QApplication () mw = QMainWindow () # creating the session session = rc . Session ( flow_theme_name = 'Samuel 1l' ) # registering one node session . register_nodes ([ PrintNode , RandNode ]) # creating a script script = session . create_script ( 'hello world' , flow_view_size = [ 800 , 500 ]) # and setting the flow widget as the windows central widget mw . setCentralWidget ( script . flow_view ) mw . show () sys . exit ( app . exec_ ()) Second Editor Here I will just throw at you the commented code for another editor that demonstrates how larger ryvencore editors will generally be structured. It was a first prototype I made for a software to simulate flows of logic gates to playfully learn how the very basic components of a computer work. CODE main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import ryvencore as rc import sys from PySide2.QtWidgets import QApplication , QMainWindow , QHBoxLayout , QWidget # nodes.py is defined below from nodes import SignalNode , ANDGateNode , ORGateNode , NANDGateNode , NORGateNode , NOTGateNode , XORGateNode , LEDNode , \\ NodeBase class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () NodeBase . main_window = self self . session = rc . Session ( flow_theme_name = 'Samuel 1l' , performance_mode = 'pretty' , parent = self ) # registering all our nodes self . session . register_nodes ( [ SignalNode , ANDGateNode , ORGateNode , NANDGateNode , NORGateNode , NOTGateNode , XORGateNode , LEDNode , ] ) self . script = self . session . create_script ( title = 'main' ) # creating a widget and adding the flow view of the script w = QWidget () w . setLayout ( QHBoxLayout ()) w . layout () . addWidget ( self . script . flow_view ) self . setCentralWidget ( w ) self . resize ( 1500 , 800 ) # resizing the window if __name__ == '__main__' : app = QApplication () mw = MainWindow () mw . show () sys . exit ( app . exec_ ()) nodes.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 import ryvencore as rc # some Qt imports... from PySide2.QtGui import Qt from PySide2.QtWidgets import QCheckBox , QPushButton class NodeBase ( rc . Node ): \"\"\"Base class for the nodes in this application\"\"\" # static rc.Node properties style = 'small' color = '#cc7777' # custom static fields main_window = None # set by MainWindow def __init__ ( self , params ): super () . __init__ ( params ) class SignalNode_MainWidget ( rc . MWB , QCheckBox ): \"\"\"Custom MainWidget for the signal node, just a simple check box for now. Note that QCheckBox is a QWidget. Also note that we must derive rc.MWB.\"\"\" def __init__ ( self , params ): rc . MWB . __init__ ( self , params ) QCheckBox . __init__ ( self ) self . setStyleSheet ( ''' QCheckBox { spacing: 10px; color: red; background-color: transparent; } ''' ) self . stateChanged . connect ( self . node . update_signal ) def get_data ( self ) -> dict : # saving the checked state return { 'checked' : self . checkState () } def set_data ( self , data : dict ): # reloading the checked state self . setChecked ( data [ 'checked' ]) class SignalNode ( NodeBase ): \"\"\"A node for generating either high or low (voltage) signals.\"\"\" title = 'signal' description = 'creates a signal, 1 or 0' init_inputs = [] init_outputs = [ rc . NodeOutput ( 'data' ) ] main_widget_class = SignalNode_MainWidget main_widget_pos = 'between ports' style = 'extended' def __init__ ( self , params ): super () . __init__ ( params ) self . signal_high = False def update_signal ( self , state ): self . signal_high = True if state == Qt . Checked else False self . update () def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( self . signal_high )) # note that 1 and 0 can be interpreted as True and False # by all the logical operators that the nodes below use def get_data ( self ) -> dict : # saving signal state return { 'signal high' : self . signal_high } def set_data ( self , data ): # reloading signal state self . signal_high = data [ 'signal high' ] class ANDGateNode ( NodeBase ): title = 'AND' description = '1 <=> both inputs are 1' init_inputs = [ rc . NodeInput ( 'data' ), rc . NodeInput ( 'data' ), ] init_outputs = [ rc . NodeOutput ( 'data' ), ] # I'd add icons here later... # icon = './...svg' def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( self . input ( 0 ) and self . input ( 1 ))) class ORGateNode ( NodeBase ): title = 'OR' description = '1 <=> at least one input is 1' init_inputs = [ rc . NodeInput ( 'data' ), rc . NodeInput ( 'data' ), ] init_outputs = [ rc . NodeOutput ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( self . input ( 0 ) or self . input ( 1 ))) class XORGateNode ( NodeBase ): title = 'XOR' description = '1 <=> exactly one input is 1' init_inputs = [ rc . NodeInput ( 'data' ), rc . NodeInput ( 'data' ), ] init_outputs = [ rc . NodeOutput ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( self . input ( 0 ) != self . input ( 1 ))) class NOTGateNode ( NodeBase ): title = 'NOT' description = 'negates the signal' init_inputs = [ rc . NodeInput ( 'data' ), ] init_outputs = [ rc . NodeOutput ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( not self . input ( 0 ))) class NANDGateNode ( NodeBase ): title = 'NAND' description = 'NOT AND' init_inputs = [ rc . NodeInput ( 'data' ), rc . NodeInput ( 'data' ), ] init_outputs = [ rc . NodeOutput ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( not ( self . input ( 0 ) and self . input ( 1 )))) class NORGateNode ( NodeBase ): title = 'NOR' description = 'NOT OR' init_inputs = [ rc . NodeInput ( 'data' ), rc . NodeInput ( 'data' ), ] init_outputs = [ rc . NodeOutput ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( not ( self . input ( 0 ) or self . input ( 1 )))) class LED_MainWidget ( rc . MWB , QPushButton ): \"\"\"LED widget for the LED node, for now just a simple disabled button\"\"\" def __init__ ( self , params ): rc . MWB . __init__ ( self , params ) QPushButton . __init__ ( self ) self . setEnabled ( False ) self . setFixedSize ( 50 , 50 ) self . setStyleSheet ( self . gen_style_sheet ( False )) def gen_style_sheet ( self , high_potential : bool ): # generate stylesheet with red background if signal is 1 # and black if signal is 0 return ''' QPushButton { border: 1px solid black; background: ''' + ( 'red' if high_potential else 'black' ) + '''; }''' def potential_updated ( self , high_potential : bool ): # called from self.node self . setStyleSheet ( self . gen_style_sheet ( high_potential )) class LEDNode ( NodeBase ): title = 'LED' description = 'shows red if signal is 1, black if it is 0' init_inputs = [ rc . NodeInput ( 'data' ) ] init_outputs = [] main_widget_class = LED_MainWidget main_widget_pos = 'between ports' def update_event ( self , input_called =- 1 ): self . main_widget () . potential_updated ( bool ( self . input ( 0 ))) And now we have a basic little editor to play around with logic gates, yayy! Congrats, you are now good to go to create much more advanced editors and optimize them. ryvencore has much more features than I showed here. For that, see the Features section where you will find more detailed descriptions of all the internal systems, from save&load over stylus-and touch-support to execution flows. The world is yours, have fun!","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#installation","text":"pip install ryvencore or from sources 1 2 3 git clone https://github.com/leon-thomm/ryvencore cd ryvencore python setup.py install Python 3.8+ recommended","title":"Installation"},{"location":"getting_started/#first-editor","text":"Info You can copy the full example code at the bottom of this page. Let's build our first editor. First thing is importing ryvencore 1 import ryvencore as rc","title":"First Editor"},{"location":"getting_started/#overall-structure","text":"Your main interface to the current project is the Session , which you usually want to create one instance of per application (but you can create more). The constructor already gives options for configurations, but we can leave everything as default for now. 1 my_session = rc . Session () Now we want to create a flow, which is part of a Script , besides the script variables and the logs . The scripts are managed by the session, so we just call 1 script = my_session . create_script ( 'hello world' , flow_view_size = [ 800 , 500 ]) With the flow_view_size you can set the pixel size of the flow view that will be created and which you can access via script.flow_view . The flow itself is a QGraphicsView subclass, which is a GUI class of Qt, so you can directly embed it into your window.","title":"Overall Structure"},{"location":"getting_started/#setting-up-a-window","text":"This is not a complete tutorial on getting started with Qt for Python, but setting up a basic GUI structure is quite simple. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import ryvencore as rc import sys from PySide2.QtWidgets import QMainWindow , QApplication if __name__ == \"__main__\" : # create a QApplication and a MainWindow # we'll subclass QMainWindow later app = QApplication () mw = QMainWindow () # creating the session session = rc . Session () # creating a script script = session . create_script ( 'hello world' , flow_view_size = [ 800 , 500 ]) # and setting the flow view as the window's central widget mw . setCentralWidget ( script . flow_view ) mw . show () sys . exit ( app . exec_ ()) And there we go, that's it. You can left click into the scene to see a node selection widget pop up. Well, there isn't any content yet to use, so let's add that.","title":"Setting Up a Window"},{"location":"getting_started/#nodes","text":"In ryvencore the nodes system works like this: A node's blueprint is defined by its class, making heavy use of Pythons static attributes system. As the accessible nodes are managed by the session, you need to register the classes of the nodes you want to use like this: 1 session . register_nodes ( list_of_nodes ) Notice You can put any code into your Node subclass, no limits! You can define additional classes, use external packages, basically everything you can do in a python class. Hint You can register (and unregister) nodes at any time! This enables dynamic import mechanisms as implemented in Ryven for example. Now let's define a simple node. For a detailed description of the members, take a look into the API reference . We'll just create a very simple print node, which prints data provided at an input every time the node is activated. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class PrintNode ( rc . Node ): # all basic properties title = 'Print' description = 'prints your data' # there is also description_html init_inputs = [ rc . NodeInput ( 'data' ) ] init_outputs = [] color = '#A9D5EF' # see API doc for a full list of all properties # we could also skip the constructor here def __init__ ( self , params ): super () . __init__ ( params ) def update_event ( self , input_called =- 1 ): data = self . input ( 0 ) # get data from the first input print ( data ) Make your class derive from rc.Node and then enhance it the way you like. The update_event is the important part, it gets triggered every time the node is supposed to update. Note While most flow-based visual scripting software out there implements either the approach of execution-flows or data-flows , ryvencore implements them both. That's what the input_called -parameter is for, you use it when creating active nodes for execution-flows. Generally, data flows are more flexible and powerful, but there are cases where exec flows make more sense, so I wanted to leave it as an option. And let's add another node which generates a random number in a given range, so we have something to print. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from random import random class RandNode ( rc . Node ): title = 'Rand' description = 'generates random float' init_inputs = [ rc . NodeInput ( 'data' , widget = 'std line edit' , widget_pos = 'besides' ) ] init_outputs = [ rc . NodeOutput ( 'data' ) ] color = '#fcba03' def update_event ( self , input_called =- 1 ): # random num between 0 and value at input val = random () * self . input ( 0 ) # setting the value of the first output self . set_output_val ( 0 , val ) Note the widget -and widget_pos -parameters in the NodePort which I explain in the following section.","title":"Nodes"},{"location":"getting_started/#finishing","text":"Now you can run this and if everything works you already have a small editor with all major features. You can place the two nodes, connect them by mouse, type something into the random node's input field and hit enter to trigger the update. It will then update and the self.set_output_val(...) call will trigger the connected print node to update and print. Of course there is much more you can do. For example you can change the flow theme. 1 session = rc . Session ( flow_theme_name = 'Samuel 1l' ) Currently available flow themes are Samuel 1d , Samuel 1l , Samuel 2d , Samuel 2l , Ueli , Blender , Simple , Toy and Tron . And if that's not enough, you can configure the theme colors for those using a json config file, so you'll definitely be able to give your flows a look that fits in the application environment it's going to be a part of. You can also change the performance mode to fast which results in some changes in rendering. 1 2 3 4 session = rc . Session ( flow_theme_name = 'Ueli' , performance_mode = 'fast' , ) CODE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import ryvencore as rc import sys from PySide2.QtWidgets import QMainWindow , QApplication from random import random class PrintNode ( rc . Node ): # all basic properties title = 'Print' description = 'prints your data' # there is also description_html init_inputs = [ rc . NodeInput ( 'data' ) ] init_outputs = [] color = '#A9D5EF' # see API doc for a full list of all properties # we could also skip the constructor here def __init__ ( self , params ): super () . __init__ ( params ) def update_event ( self , input_called =- 1 ): data = self . input ( 0 ) # get data from the first input print ( data ) class RandNode ( rc . Node ): title = 'Rand' description = 'generates random float' init_inputs = [ rc . NodeInput ( 'data' , widget = 'std line edit' , widget_pos = 'besides' ) ] init_outputs = [ rc . NodeOutput ( 'data' ) ] color = '#fcba03' def update_event ( self , input_called =- 1 ): # random num between 0 and value at input val = random () * self . input ( 0 ) # setting the value of the first output self . set_output_val ( 0 , val ) if __name__ == \"__main__\" : # create a QApplication and a MainWindow # the QMainWindow will be subclassed later app = QApplication () mw = QMainWindow () # creating the session session = rc . Session ( flow_theme_name = 'Samuel 1l' ) # registering one node session . register_nodes ([ PrintNode , RandNode ]) # creating a script script = session . create_script ( 'hello world' , flow_view_size = [ 800 , 500 ]) # and setting the flow widget as the windows central widget mw . setCentralWidget ( script . flow_view ) mw . show () sys . exit ( app . exec_ ())","title":"Finishing"},{"location":"getting_started/#second-editor","text":"Here I will just throw at you the commented code for another editor that demonstrates how larger ryvencore editors will generally be structured. It was a first prototype I made for a software to simulate flows of logic gates to playfully learn how the very basic components of a computer work. CODE main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import ryvencore as rc import sys from PySide2.QtWidgets import QApplication , QMainWindow , QHBoxLayout , QWidget # nodes.py is defined below from nodes import SignalNode , ANDGateNode , ORGateNode , NANDGateNode , NORGateNode , NOTGateNode , XORGateNode , LEDNode , \\ NodeBase class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () NodeBase . main_window = self self . session = rc . Session ( flow_theme_name = 'Samuel 1l' , performance_mode = 'pretty' , parent = self ) # registering all our nodes self . session . register_nodes ( [ SignalNode , ANDGateNode , ORGateNode , NANDGateNode , NORGateNode , NOTGateNode , XORGateNode , LEDNode , ] ) self . script = self . session . create_script ( title = 'main' ) # creating a widget and adding the flow view of the script w = QWidget () w . setLayout ( QHBoxLayout ()) w . layout () . addWidget ( self . script . flow_view ) self . setCentralWidget ( w ) self . resize ( 1500 , 800 ) # resizing the window if __name__ == '__main__' : app = QApplication () mw = MainWindow () mw . show () sys . exit ( app . exec_ ()) nodes.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 import ryvencore as rc # some Qt imports... from PySide2.QtGui import Qt from PySide2.QtWidgets import QCheckBox , QPushButton class NodeBase ( rc . Node ): \"\"\"Base class for the nodes in this application\"\"\" # static rc.Node properties style = 'small' color = '#cc7777' # custom static fields main_window = None # set by MainWindow def __init__ ( self , params ): super () . __init__ ( params ) class SignalNode_MainWidget ( rc . MWB , QCheckBox ): \"\"\"Custom MainWidget for the signal node, just a simple check box for now. Note that QCheckBox is a QWidget. Also note that we must derive rc.MWB.\"\"\" def __init__ ( self , params ): rc . MWB . __init__ ( self , params ) QCheckBox . __init__ ( self ) self . setStyleSheet ( ''' QCheckBox { spacing: 10px; color: red; background-color: transparent; } ''' ) self . stateChanged . connect ( self . node . update_signal ) def get_data ( self ) -> dict : # saving the checked state return { 'checked' : self . checkState () } def set_data ( self , data : dict ): # reloading the checked state self . setChecked ( data [ 'checked' ]) class SignalNode ( NodeBase ): \"\"\"A node for generating either high or low (voltage) signals.\"\"\" title = 'signal' description = 'creates a signal, 1 or 0' init_inputs = [] init_outputs = [ rc . NodeOutput ( 'data' ) ] main_widget_class = SignalNode_MainWidget main_widget_pos = 'between ports' style = 'extended' def __init__ ( self , params ): super () . __init__ ( params ) self . signal_high = False def update_signal ( self , state ): self . signal_high = True if state == Qt . Checked else False self . update () def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( self . signal_high )) # note that 1 and 0 can be interpreted as True and False # by all the logical operators that the nodes below use def get_data ( self ) -> dict : # saving signal state return { 'signal high' : self . signal_high } def set_data ( self , data ): # reloading signal state self . signal_high = data [ 'signal high' ] class ANDGateNode ( NodeBase ): title = 'AND' description = '1 <=> both inputs are 1' init_inputs = [ rc . NodeInput ( 'data' ), rc . NodeInput ( 'data' ), ] init_outputs = [ rc . NodeOutput ( 'data' ), ] # I'd add icons here later... # icon = './...svg' def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( self . input ( 0 ) and self . input ( 1 ))) class ORGateNode ( NodeBase ): title = 'OR' description = '1 <=> at least one input is 1' init_inputs = [ rc . NodeInput ( 'data' ), rc . NodeInput ( 'data' ), ] init_outputs = [ rc . NodeOutput ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( self . input ( 0 ) or self . input ( 1 ))) class XORGateNode ( NodeBase ): title = 'XOR' description = '1 <=> exactly one input is 1' init_inputs = [ rc . NodeInput ( 'data' ), rc . NodeInput ( 'data' ), ] init_outputs = [ rc . NodeOutput ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( self . input ( 0 ) != self . input ( 1 ))) class NOTGateNode ( NodeBase ): title = 'NOT' description = 'negates the signal' init_inputs = [ rc . NodeInput ( 'data' ), ] init_outputs = [ rc . NodeOutput ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( not self . input ( 0 ))) class NANDGateNode ( NodeBase ): title = 'NAND' description = 'NOT AND' init_inputs = [ rc . NodeInput ( 'data' ), rc . NodeInput ( 'data' ), ] init_outputs = [ rc . NodeOutput ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( not ( self . input ( 0 ) and self . input ( 1 )))) class NORGateNode ( NodeBase ): title = 'NOR' description = 'NOT OR' init_inputs = [ rc . NodeInput ( 'data' ), rc . NodeInput ( 'data' ), ] init_outputs = [ rc . NodeOutput ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( not ( self . input ( 0 ) or self . input ( 1 )))) class LED_MainWidget ( rc . MWB , QPushButton ): \"\"\"LED widget for the LED node, for now just a simple disabled button\"\"\" def __init__ ( self , params ): rc . MWB . __init__ ( self , params ) QPushButton . __init__ ( self ) self . setEnabled ( False ) self . setFixedSize ( 50 , 50 ) self . setStyleSheet ( self . gen_style_sheet ( False )) def gen_style_sheet ( self , high_potential : bool ): # generate stylesheet with red background if signal is 1 # and black if signal is 0 return ''' QPushButton { border: 1px solid black; background: ''' + ( 'red' if high_potential else 'black' ) + '''; }''' def potential_updated ( self , high_potential : bool ): # called from self.node self . setStyleSheet ( self . gen_style_sheet ( high_potential )) class LEDNode ( NodeBase ): title = 'LED' description = 'shows red if signal is 1, black if it is 0' init_inputs = [ rc . NodeInput ( 'data' ) ] init_outputs = [] main_widget_class = LED_MainWidget main_widget_pos = 'between ports' def update_event ( self , input_called =- 1 ): self . main_widget () . potential_updated ( bool ( self . input ( 0 ))) And now we have a basic little editor to play around with logic gates, yayy! Congrats, you are now good to go to create much more advanced editors and optimize them. ryvencore has much more features than I showed here. For that, see the Features section where you will find more detailed descriptions of all the internal systems, from save&load over stylus-and touch-support to execution flows. The world is yours, have fun!","title":"Second Editor"}]}